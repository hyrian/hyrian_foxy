# ROS GPT 노드 구성 및 키워드 전달 

구조도에 따라 코드를 수정하기 위한 과정을 개략적으로 설명한 것


1. **노드 및 토픽 정의:** 각 노드가 어떤 토픽을 구독하고 발행할 것인지 정의해야 합니다. 구조도에서는 각 노드가 특정 키워드에 반응하여 메시지를 발행하는 것으로 보입니다.
2. **상태 머신 설계**: 중앙의 검은색 노드는 사용자의 결정을 나타내므로 이것을 실제 ROS2에서 상태 머신으로 구현해야 합니다. 각 상태에 따라 특정 토픽 메시지를 발행하거나, 특정 서비스를 호출하는 로직을 구현합니다.
3. **메시지 정의 및 발행:** 구조도에서 노란색으로 표시된 'publisher' 노드들은 특정 메시지를 발행해야 합니다. 이 메시지들은 표준 String 타입일 수도 있고, 복잡한 데이터 구조를 가진 사용자 정의 메시지 타입일 수도 있습니다.
4. **음성 인식 및 대화 관리**: 사용자와의 인터랙션은 음성 인식을 통해 시작됩니다. 음성 인식 결과에 따라 다음 상태로 전이하거나, 적절한 피드백을 제공해야 합니다.
5. **음성 합성 및 재생**: 사용자와의 대화 흐름에서
    
    음성 합성 및 재생은 사용자와의 상호작용에서 중요한 부분을 차지합니다. 사용자의 요청에 대한 응답으로 텍스트를 음성으로 변환하고, 이를 재생하는 과정을 자동화해야 합니다.
    
    a. 서비스 및 클라이언트 관리: 일부 노드는 서비스를 제공하고, 다른 노드는 이러한 서비스를 사용합니다. 예를 들어, 사용자의 요청에 따라 특정 서비스를 호출하고 결과를 기다리는 로직을 구현해야 합니다.
    
    b. 로깅 및 에러 핸들링: 시스템의 각 부분에서 발생할 수 있는 예외 사항들을 적절히 처리하고 로깅하여, 시스템의 안정성을 보장해야 합니다.
    
    c. 클린업 및 자원 관리: 프로그램 종료 시 모든 자원을 정리하고, 불필요한 파일을 삭제하는 등의 클린업 로직을 구현해야 합니다.
    
    d. 테스트 및 디버깅: 개발 과정에서 단위 테스트와 시스템 테스트를 수행하여, 각 컴포넌트가 예상대로 작동하는지 확인해야 합니다.
    

---

구체적인 코드 수정을 위해서는, 기존에 제공된 코드의 각 부분을 구조도의 각 노드와 매칭시키고, 해당 노드에서 필요한 기능을 수행하는 로직을 추가하거나 수정해야 합니다. 예를 들어, 구조도에 따라 음성 인식 결과에 따라 다른 키워드를 발행하는 로직을 추가하거나, 특정 조건에서 서비스를 호출하는 로직을 구현할 수 있습니다.

각 기능에 대한 구현은 이미 코드에 어느 정도 존재하기 때문에, 필요한 것은 이 기능들을 구조도에 맞게 조합하고 흐름을 관리하는 것입니다. 각 상태와 전이를 코드로 표현하고, 의도한 대로 메시지가 발행되고 처리되는지 확인하기 위해 ROS2의 로깅 기능과 함께 테스트를 진행해야 합니다.

이러한 과정을 통해 구조도에 따른 ROS2 기반 대화 시스템을 구현할 수 있습니다. 현재 코드는 이미 상당한 기능을 갖추고 있기 때문에, 위의 단계를 참고하여 코드를 추가하고 조정하면 목표에 도달할 수 있을 것입니다.

# 상태 머신 구현

상태 머신의 각 상태와 시나리오를 메소드 작동 시퀀스에 맞추어 정리해 보겠습니다. 이 과정은 로봇이 사용자와의 상호작용을 시작하고, 다양한 요청을 처리하며, 서비스를 종료하는 전체 흐름을 보여줍니다.

1. **WAITING 상태**:
    - 로봇은 `WAITING` 상태에서 시작하여, 고객을 감지하기 위해 대기합니다.
    - 일정 시간(예: 5초) 후, `GREETING` 상태로 전환합니다.
    - 대기 중인 상태, 특별한 토픽 발행 없음.
2. **GREETING 상태**:
    - `greet_customer` 메소드를 통해 고객에게 인사합니다.
    - 인사 후, `CONFIRMING_SERVICE_USE` 상태로 전환합니다.
    - 고객에게 인사 메시지 발행: `[Gesture][Greeting]`.
3. **CONFIRMING_SERVICE_USE 상태**:
    - `record_audio` 메소드로 고객의 응답을0ㅣ 녹음합니다.
    - `transcribe_audio` 메소드로 녹음된 음성을 텍스트로 변환합니다.
    - 고객이 서비스를 원한다고 응답하면 `EXPLAINING_USAGE`로, 아니면 `GENERAL_CONVERSATION`으로 전환합니다.
4. **EXPLAINING_USAGE 상태**:
    - 로봇은 사용 방법을 설명합니다.
    - 사용 방법 설명 메시지 발행: `[Gesture][Explain]`.
    - 설명 후, `LISTENING_FOR_REQUEST` 상태로 전환합니다.
5. **LISTENING_FOR_REQUEST 상태**:
    - 고객의 요청을 듣습니다.
    - 요청 듣기 전 제스처 발행: `[Gesture][Recording]`
        
        `LISTENING_FOR_REQUEST` 상태에서 `arrival_flag`에 따른 동작을 설명하겠습니다. 이 상태는 로봇이 고객의 요청을 듣고 처리하는 중요한 단계입니다. `arrival_flag`는 로봇이 특정 코너에 도착했는지를 나타내는 플래그로 사용됩니다.
        
        1. **`arrival_flag`가 0인 경우 (도착 전)**:
            - 이 경우 로봇은 아직 코너에 도착하지 않았으므로, 고객의 요청을 듣고 키워드 분석(`KEYWORD_ANALYSIS`)을 수행합니다.
            - 고객의 요청에 특정 키워드(예: "옷", "신발", "전자기기", "책")가 포함되어 있다면 `PROVIDING_INFORMATION` 상태로 전환하여 관련 정보를 제공합니다.
            - 키워드가 없으면 `GENERAL_CONVERSATION` 상태로 전환하여 일반 대화를 계속합니다.
        2. **`arrival_flag`가 1 이상인 경우 (도착 후)**:
            - 이 경우 로봇은 특정 코너에 도착한 상태이므로, 고객의 요청에 따라 다르게 반응합니다.
            - 고객이 "종료"라고 요청하면 `END_CONFIRM` 상태로 전환하여 서비스 종료 여부를 확인합니다.
            - 고객의 요청에 키워드가 포함되어 있다면 `PROVIDING_INFORMATION` 상태로 다시 전환하여 추가 정보를 제공합니다.
            - 고객이 구매와 관련된 요청("얼마야", "구매")을 하면 `SALES` 상태로 전환하여 구매 관련 도움을 제공합니다.
            - 그 외의 경우에는 `GENERAL_CONVERSATION`으로 전환하여 일반 대화를 계속합니다.
        
        `arrival_flag`는 로봇이 고객과 함께 이동한 후 특정 코너에 도착했음을 나타내는 중요한 지표입니다. 이 플래그를 통해 로봇은 도착 전과 도착 후의 상황에 따라 다르게 반응할 수 있으며, 고객의 요청에 더 적절하게 대응할 수 있습니다.
        
6. **KEYWORD_ANALYSIS 상태**:
    - 고객의 요청에서 키워드를 분석합니다.
    - 키워드 분석 메시지 발행: `[State][KeywordAnalysis]`.
    - `PROVIDING_INFORMATION` 상태로 전환합니다.
7. **PROVIDING_INFORMATION 상태**:
    - 키워드에 해당하는 정보를 제공합니다.
    - 제공 정보 메시지 발행: `[State][ProvidingInformation]`
    - `CONFIRMING_MOVEMENT` 상태로 전환합니다.
8. **CONFIRMING_MOVEMENT 상태**:
    - 고객이 특정 코너로 이동을 원하는지 확인합니다.
    - 이동 확인 메시지 발행: `[State][ConfirmingMovement]`
    - 고객의 응답에 따라 `MOVING` 또는 `GENERAL_CONVERSATION`으로 전환합니다.
9. **MOVING 상태**:
    - 고객과 함께 코너로 이동합니다.
    - 이동 중 메시지 발행: `[State][Moving]`
    - `ARRIVAL` 상태로 전환합니다.
10. **ARRIVAL 상태**:
    - 코너에 도착합니다.
    - 도착 메시지 발행: `[State][Arrival]`.
    - `LISTENING_FOR_REQUEST` 상태로 다시 전환합니다.
11. **SALES 상태**:
    - 구매 관련 질문을 처리합니다.
    - 판매 관련 메시지 발행: `[HRI][<keyword>_sales]`
    - `PURCHASE_CONFIRM` 상태로 전환합니다.
12. **PURCHASE_CONFIRM 상태**:
    - 구매 결정을 확인합니다.
    - 구매 확인 메시지 발행: `[HRI][PurchaseConfirm]`
    - 고객의 응답에 따라 다음 단계로 진행합니다.
13. **END_CONFIRM 상태**:
    - 서비스 종료 여부를 확인합니다.
    - 서비스 종료 확인 메시지 발행: `[State][EndConfirm]`
    - 고객의 응답에 따라 `ENDING` 또는 `LISTENING_FOR_REQUEST`로 전환합니다.
14. **GENERAL_CONVERSATION 상태**:
    - 일반 대화를 진행합니다.
    - 일반 대화 메시지 발행: `[State][GeneralConversation]`
    - 대화 후 `LISTENING_FOR_REQUEST`로 전환합니다.
15. **ENDING 상태**:
    - 서비스를 종료하고 종료 인사를 합니다.
    - 종료 인사 및 복귀 메시지 발행: `[Navigation][Return]`
    - `WAITING` 상태로 돌아가거나 프로세스를 종료합니다.
    

이 시퀀스는 로봇이 사용자와의 상호작용을 어떻게 관리하는지를 보여주며, 각 상태에서의 주요 작업과 상태 간 전환을 설명합니다. 로봇은 사용자의 요청과 환경에 따라 유연하게 다양한 상태로 전환하며 서비스를 제공합니다.
